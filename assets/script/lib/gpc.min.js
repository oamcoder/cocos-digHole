"use strict";window.gpc=window.gpc||(()=>{var e=Object.defineProperty,t=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,l={};((t,n)=>{for(var o in n)e(t,o,{get:n[o],enumerable:!0})})(l,{AetTree:()=>s,BundleState:()=>u,CLIP:()=>c,EPSILON:()=>b,EQ:()=>y,EdgeNode:()=>P,EdgeTable:()=>T,HState:()=>w,ItNodeTable:()=>W,LEFT:()=>a,LmtNode:()=>A,LmtTable:()=>_,NEXT_INDEX:()=>g,OPTIMAL:()=>U,OperationType:()=>f,PREV_INDEX:()=>v,Polygon:()=>oe,PolygonNode:()=>O,Position:()=>K,RIGHT:()=>p,Rectangle:()=>m,SUBJ:()=>d,ScanBeamTreeEntries:()=>C,StNode:()=>Y,TopPolygonNode:()=>k,VertexNode:()=>i,VertexType:()=>L,addSTEdge:()=>G,buildLmt:()=>B,clip:()=>Q,contourPass:()=>I,convexHull:()=>te,forceWinding:()=>R,getVertexType:()=>E,isContributing:()=>h,isConvex:()=>V,isSimple:()=>X,polygonArea:()=>j,polygonHull:()=>ee,rotateBottomLeft:()=>D,setContributing:()=>x,vert_eql:()=>r,wn_poly:()=>Z});var s=class{constructor(){this.top=null}addEdge(e){if(null===this.top)return this.top=e,e.prev=null,void(e.next=null);let t=null,n=this.top;for(;;){if(e.xb<n.xb||e.xb===n.xb&&e.dx<n.dx)return e.prev=t,e.next=n,n.prev=e,void(null===t?this.top=e:t.next=e);if(t=n,null===n.next)return n.next=e,e.prev=n,void(e.next=null);n=n.next}}};function r(e,t){return e.x===t.x&&e.y===t.y}var i=class{constructor(e,t,n=null){this.x=e,this.y=t,this.next=n}},u=(e=>(e[e.UNBUNDLED=0]="UNBUNDLED",e[e.BUNDLE_HEAD=1]="BUNDLE_HEAD",e[e.BUNDLE_TAIL=2]="BUNDLE_TAIL",e))(u||{}),b=2220446049250313e-31,a=0,p=1,c=0,d=1,h=Symbol(),x=Symbol(),f=(e=>(e[e.DIF=0]="DIF",e[e.INT=1]="INT",e[e.XOR=2]="XOR",e[e.ADD=3]="ADD",e))(f||{});function y(e,t){return Math.abs(e-t)<=b}function v(e,t){return(e-1+t)%t}function g(e,t){return(e+1)%t}var w,N,L=(e=>(e[e.NUL=0]="NUL",e[e.EMX=1]="EMX",e[e.ELI=2]="ELI",e[e.TED=3]="TED",e[e.ERI=4]="ERI",e[e.RED=5]="RED",e[e.IMM=6]="IMM",e[e.IMN=7]="IMN",e[e.EMN=8]="EMN",e[e.EMM=9]="EMM",e[e.LED=10]="LED",e[e.ILI=11]="ILI",e[e.BED=12]="BED",e[e.IRI=13]="IRI",e[e.IMX=14]="IMX",e[e.FUL=15]="FUL",e))(L||{});function E(e,t,n,o){return e+(t<<1)+(n<<2)+(o<<3)}(N=w||(w={})).NH=0,N.BH=1,N.TH=2,N.nextState=[[N.BH,N.TH,N.TH,N.BH,N.NH,N.NH],[N.NH,N.NH,N.NH,N.NH,N.TH,N.TH],[N.NH,N.NH,N.NH,N.NH,N.BH,N.BH]];var m=class{constructor(e,t,n,o){this.minx=e,this.miny=t,this.maxx=n,this.maxy=o}};function j(e){const t=e.length;let n=0,{x:o,y:l}=e[t-1];for(let s=0;s<t;s++){const{x:t,y:r}=e[s];n+=(o+t)*(l-r),o=t,l=r}return n/2}function M(e,t){if(null===e.top)return e.top=new A(t),e.top;let n=null,o=e.top;for(;;){if(!(t>o.y))return t<o.y&&(o=new A(t,o),null===n?e.top=o:n.next=o),o;if(null===o.next)return o.next=new A(t),o.next;[n,o]=[o,o.next]}}function H(e,t){if(null===e.firstBound)return void(e.firstBound=t);let n=null,o=e.firstBound;for(;;){if(t.bot.x<o.bot.x||t.bot.x===o.bot.x&&t.dx<o.dx)return null===n?e.firstBound=t:n.nextBound=t,void(t.nextBound=o);if(null===o.nextBound)return void(o.nextBound=t);n=o,o=o.nextBound}}function I(e,t,n,o,l,s,r){const i=r?g:v;for(let u=0;u<n;u++)if(r?e.FWD_MIN(u):e.REV_MIN(u)){let b=1,h=i(u,n);for(;r?e.NOT_FMAX(h):e.NOT_RMAX(h);)b++,h=i(h,n);let x=u;const f=e.getNode(o);f.bstate.below=0,f.bundle.below[c]=0,f.bundle.below[d]=0;for(let t=0;t<b;t++){const r=e.getNode(o+t);let u=e.getNode(x);r.xb=u.vertex.x,r.bot.x=u.vertex.x,r.bot.y=u.vertex.y,x=i(x,n),u=e.getNode(x),r.top.x=u.vertex.x,r.top.y=u.vertex.y,r.dx=(u.vertex.x-r.bot.x)/(r.top.y-r.bot.y),r.type=l,r.outp.above=null,r.outp.below=null,r.next=null,r.prev=null,r.succ=b>1&&t<b-1?e.getNode(o+t+1):null,r.pred=b>1&&t>0?e.getNode(o+t-1):null,r.nextBound=null,r.bside.clip=0===s?p:a,r.bside.subj=a}H(M(t,e.getNode(u).vertex.y),f),o+=b}return o}var P=class{constructor(e,t){this.bot={x:NaN,y:NaN},this.top={x:NaN,y:NaN},this.xb=NaN,this.xt=NaN,this.dx=NaN,this.type=0,this.prev=null,this.next=null,this.pred=null,this.succ=null,this.nextBound=null,this.vertex={x:e,y:t},this.bside={clip:0,subj:0},this.bundle={above:[0,0],below:[0,0]},this.bstate={above:null,below:null},this.outp={above:null,below:null}}},T=class{constructor(){this.nodeList=[]}addNode(e,t){this.nodeList.push(new P(e,t))}getNode(e){return this.nodeList[e]}FWD_MIN(e){const t=this.nodeList,n=t[v(e,t.length)],o=t[g(e,t.length)],l=t[e];return n.vertex.y>=l.vertex.y&&o.vertex.y>l.vertex.y}NOT_FMAX(e){const t=this.nodeList,n=t[g(e,t.length)],o=t[e];return n.vertex.y>o.vertex.y}REV_MIN(e){const t=this.nodeList,n=t[v(e,t.length)],o=t[g(e,t.length)],l=t[e];return n.vertex.y>l.vertex.y&&o.vertex.y>=l.vertex.y}NOT_RMAX(e){const t=this.nodeList,n=t[v(e,t.length)],o=t[e];return n.vertex.y>o.vertex.y}};function U(e,t){const{y:n}=e.get(t),o=e.getNumPoints();return e.get(v(t,o)).y!==n||e.get(g(t,o)).y!==n}var A=class{constructor(e,t=null){this.y=e,this.next=t,this.firstBound=null}},_=class{constructor(){this.top=null}};function B(e,t,n,o,l){for(const s of n.getInnerPolies())if(s[h](0)){let n=0;const r=new T,i=s.getNumPoints();for(let e=0;e<i;e++)if(U(s,e)){const{x:o,y:l}=s.get(e);r.addNode(o,l),t.addToSBTree(l),n++}const u=I(r,e,n,0,o,l,!0);I(r,e,n,u,o,l,!1)}else s[x](0,!0)}function D(e){const t=function(e){const t=e.length;let{x:n,y:o}=e[0],l=0;for(let s=1;s<t;s++){const{x:t,y:r}=e[s];(r<o||o==r&&t<n)&&(o=r,n=t,l=s)}return l}(e);return 0===t?e:function(e,t){const n=t.slice(e);for(let o=0;o<e;o++)n.push(t[o]);return n}(t,e)}function R(e,t){const n=e*j(t);if(n>=0)return e*n;for(let e=1,n=t.length-1;e<n;e++,n--){const o=t[e];t[e]=t[n],t[n]=o}return e*Math.abs(n)}var S=2*Math.PI;function V(e){const t=e.length;if(t<=3)return!0;let{x:n,y:o}=e[t-2],{x:l,y:s}=e[t-1],r=0,i=Math.atan2(s-o,l-n),u=0,b=0;for(let a=0;a<t;a++){const t=e[a];n=l,o=s,r=i,l=t.x,s=t.y,i=Math.atan2(s-o,l-n);let p=i-r;if(p<=-Math.PI?p+=S:p>Math.PI&&(p-=S),0===b)b=p;else if(b*p<0)return!1;u+=p}return 1===Math.abs(Math.round(u/S))}function X(e){const t=e.length;if(t<=3)return!0;let{x:n,y:o}=e[t-2],{x:l,y:s}=e[t-1],r=0,i=Math.atan2(s-o,l-n),u=0;for(let b=0;b<t;b++){const t=e[b];n=l,o=s,r=i,l=t.x,s=t.y,i=Math.atan2(s-o,l-n);let a=i-r;a<=-Math.PI?a+=S:a>Math.PI&&(a-=S),u+=a}return 1===Math.abs(Math.round(u/S))}var O=class{constructor(e,t,n){this.active=!0,this.hole=!1;const o=new i(t,n);this.left=o,this.right=o,this.next=e,this.proxy=this}addRight(e,t){const n=new i(e,t);this.proxy.right.next=n,this.proxy.right=n}addLeft(e,t){this.proxy.left=new i(e,t,this.proxy.left)}},k=class{constructor(e,t){this.Simple=e,this.Compound=t,this.top=null}addLocalMin(e,t){const n=new O(this.top,e,t);return this.top=n,n}mergeLeft(e,t){if(t.proxy.hole=!0,e.proxy!==t.proxy){e.proxy.right.next=t.proxy.left,t.proxy.left=e.proxy.left;const n=e.proxy;for(let e=this.top;null!==e;e=e.next)e.proxy===n&&(e.active=!1,e.proxy=t.proxy)}}mergeRight(e,t){if(t.proxy.hole=!1,e.proxy!==t.proxy){t.proxy.right.next=e.proxy.left,t.proxy.right=e.proxy.right;const n=e.proxy;for(let e=this.top;null!==e;e=e.next)e.proxy===n&&(e.active=!1,e.proxy=t.proxy)}}getContours(){const e=[];e:for(let t=this.top;null!==t;t=t.next){if(!t.active)continue;let n=0;for(let o=t.proxy.left;null!==o;o=o.next)if(++n>2){e.push(t);continue e}t.active=!1}return e}getResult(){const e=this.getContours();if(0===e.length)return new this.Simple([],!1);const t=e.flatMap((e=>{const t=[],n=e.proxy.hole;let o=[];for(let l=e.proxy.left;null!==l;l=l.next){for(let e=o.length-1;e>=0;e--)r(o[e],l)&&(t.push(new this.Simple(D(o.slice(e)),n)),o.length=e);o.push({x:l.x,y:l.y})}return t.push(new this.Simple(D(o),n)),t}));return 1===t.length?t[0]:new this.Compound(t)}},F=class{constructor(e){this.y=e,this.less=null,this.more=null}},C=class{constructor(){this.sbtEntries=0,this.sbTree=null}addToSBTree(e){if(null===this.sbTree)return this.sbTree=new F(e),void this.sbtEntries++;let t=this.sbTree;for(;t.y!==e;){const n=t.y>e?"less":"more",o=t[n];if(null===o)return t[n]=new F(e),void this.sbtEntries++;t=o}}buildSBT(){if(null===this.sbTree)return[];const e=[];return function e(t,n,o){return null!==o.less&&(t=e(t,n,o.less)),n[t]=o.y,t++,null!==o.more&&(t=e(t,n,o.more)),t}(0,e,this.sbTree),e}},Y=class{constructor(e,t){this.edge=e,this.xb=e.xb,this.xt=e.xt,this.dx=e.dx,this.prev=t}},q=class{constructor(e,t,n,o,l){this.ie=[e,t],this.point={x:n,y:o},this.next=l}},W=class{constructor(){this.top=null}buildIntersectionTable(e,t){let n=null;for(let o=e.top;null!==o;o=o.next)1!==o.bstate.above&&0===o.bundle.above[c]&&0===o.bundle.above[d]||(n=G(n,this,o,t))}};function J(e,t,n,o,l){return null===e||e.point.y>l?new q(t,n,o,l,e):(e.next=J(e.next,t,n,o,l),e)}function G(e,t,n,o){if(null===e)return new Y(n,null);const l=e.xt-e.xb-(n.xt-n.xb);if(n.xt>=e.xt||n.dx===e.dx||Math.abs(l)<=b)return new Y(n,e);const s=(n.xb-e.xb)/l,r=e.xb+s*(e.xt-e.xb),i=s*o;return t.top=J(t.top,e.edge,n,r,i),e.prev=G(e.prev,t,n,o),e}function Q(e,t,n,o,l){const r=t.isEmpty,i=n.isEmpty;if(i&&1===e||r&&(i||1===e||0===e))return new o([],!1);1!==e&&0!==e||r||i||function(e,t,n){const o=e.getInnerPolies().map((e=>e.bounds)),l=t.getInnerPolies().map((e=>e.bounds)),s=l.map((e=>o.map((t=>!(t.maxx<e.minx||t.minx>e.maxx||t.maxy<e.miny||t.miny>e.maxy))))),r=l.length;for(let e=0;e<r;e++)s[e].every((e=>e))||t[x](e,!1);if(1===n){const t=o.length;for(let n=0;n<t;n++)s.every((e=>e[n]))||e[x](n,!1)}}(t,n,e);const u=new _,b=new C;if(r||B(u,b,t,d,e),i||B(u,b,n,c,e),null===u.top)return new o([],!1);const h={clip:0===e?p:a,subj:a},f=b.buildSBT(),v=new k(o,l),g=new s;let N=0,L=u.top;for(;N<f.length;){const t=f[N++];let n=0,o=0;if(N<f.length&&(n=f[N],o=n-t),null!==L&&L.y===t){for(let e=L.firstBound;null!==e;e=e.nextBound)g.addEdge(e);L=L.next}if(null===g.top)throw new Error("Encountered Unexpected Null Edge");let l=g.top,s=g.top;g.top.bundle.above[g.top.type]=g.top.top.y!==t?1:0,g.top.bundle.above[1-g.top.type]=0,g.top.bstate.above=0;for(let e=g.top.next;null!==e;e=e.next){const n=e.type,o=1-n;e.bundle.above[n]=e.top.y!==t?1:0,e.bundle.above[o]=0,e.bstate.above=0,1===e.bundle.above[n]&&(y(l.xb,e.xb)&&y(l.dx,e.dx)&&l.top.y!==t&&(e.bundle.above[n]^=l.bundle.above[n],e.bundle.above[o]=l.bundle.above[o],e.bstate.above=1,l.bundle.above[c]=0,l.bundle.above[d]=0,l.bstate.above=2),l=e)}const r={clip:w.NH,subj:w.NH},i={clip:0,subj:0};let u=-Number.MAX_VALUE,a=null;for(let n=g.top;null!==n;n=n.next){if(i.clip=n.bundle.above[c]+(n.bundle.below[c]<<1),i.subj=n.bundle.above[d]+(n.bundle.below[d]<<1),0==(i.clip|i.subj))continue;n.bside.clip=h.clip,n.bside.subj=h.subj;let o=!1,l=0,s=0,b=0,p=0;if(0===e||1===e?(o=0!==i.clip&&(0!==h.subj||0!==r.subj)||0!==i.subj&&(0!==h.clip||0!==r.clip)||0!==i.clip&&0!==i.subj&&h.clip===h.subj,l=h.clip&h.subj,s=(h.clip^n.bundle.above[c])&(h.subj^n.bundle.above[d]),b=(h.clip^(r.clip!==w.NH?1:0))&(h.subj^(r.subj!==w.NH?1:0)),p=(h.clip^(r.clip!==w.NH?1:0)^n.bundle.below[c])&(h.subj^(r.subj!==w.NH?1:0)^n.bundle.below[d])):2===e?(o=0!==i.clip||0!==i.subj,l=h.clip^h.subj,s=h.clip^n.bundle.above[c]^h.subj^n.bundle.above[d],b=h.clip^(r.clip!==w.NH?1:0)^h.subj^(r.subj!==w.NH?1:0),p=h.clip^(r.clip!==w.NH?1:0)^n.bundle.below[c]^h.subj^(r.subj!==w.NH?1:0)^n.bundle.below[d]):3===e&&(o=!((0===i.clip||0!==h.subj&&0===r.subj)&&(0===i.subj||0!==h.clip&&0===r.clip)&&(0===i.clip||0===i.subj||h.clip!==h.subj)),l=h.clip|h.subj,s=h.clip^n.bundle.above[c]|h.subj^n.bundle.above[d],b=h.clip^(r.clip!==w.NH?1:0)|h.subj^(r.subj!==w.NH?1:0),p=h.clip^(r.clip!==w.NH?1:0)^n.bundle.below[c]|h.subj^(r.subj!==w.NH?1:0)^n.bundle.below[d]),h.clip^=n.bundle.above[c],h.subj^=n.bundle.above[d],0!==i.clip&&(r.clip=w.nextState[r.clip][(i.clip-1<<1)+h.clip]),0!==i.subj&&(r.subj=w.nextState[r.subj][(i.subj-1<<1)+h.subj]),!o)continue;const{xb:x}=n;switch(E(b,p,l,s)){case 8:case 7:a=v.addLocalMin(x,t),u=x,n.outp.above=a;break;case 4:if(null===a)throw new Error("Unexpected Null Polygon");x!==u&&(a.addRight(x,t),u=x),n.outp.above=a,a=null;break;case 2:if(a=n.outp.below,null===a)throw new Error("Unexpected Null Polygon");a.addLeft(x,t),u=x;break;case 1:if(null===a)throw new Error("Unexpected Null Polygon");if(null===n.outp.below)throw new Error("Unexpected Null Polygon");x!==u&&(a.addLeft(x,t),u=x),v.mergeRight(a,n.outp.below),a=null;break;case 11:if(null===a)throw new Error("Unexpected Null Polygon");x!==u&&(a.addLeft(x,t),u=x),n.outp.above=a,a=null;break;case 13:if(a=n.outp.below,null===a)throw new Error("Unexpected Null Polygon");a.addRight(x,t),u=x,n.outp.below=null;break;case 14:if(null===a)throw new Error("Unexpected Null Polygon");if(null===n.outp.below)throw new Error("Unexpected Null Polygon");x!==u&&(a.addRight(x,t),u=x),v.mergeLeft(a,n.outp.below),a=null,n.outp.below=null;break;case 6:if(null===a)throw new Error("Unexpected Null Polygon");if(null===n.outp.below)throw new Error("Unexpected Null Polygon");x!==u&&(a.addRight(x,t),u=x),v.mergeLeft(a,n.outp.below),n.outp.below=null,a=v.addLocalMin(x,t),n.outp.above=a;break;case 9:if(null===a)throw new Error("Unexpected Null Polygon");if(null===n.outp.below)throw new Error("Unexpected Null Polygon");x!==u&&(a.addLeft(x,t),u=x),v.mergeRight(a,n.outp.below),n.outp.below=null,a=v.addLocalMin(x,t),n.outp.above=a;break;case 10:if(null===n.outp.below)throw new Error("Unexpected Null Polygon");n.bot.y===t&&n.outp.below.addLeft(x,t),n.outp.above=n.outp.below,u=x;break;case 5:if(null===n.outp.below)throw new Error("Unexpected Null Polygon");n.bot.y===t&&n.outp.below.addRight(x,t),n.outp.above=n.outp.below,u=x}}for(let e=g.top;null!==e;e=e.next)if(e.top.y===t){const{prev:t,next:n}=e;null===t?g.top=n:t.next=n,null!==n&&(n.prev=t),1===e.bstate.below&&null!==t&&2===t.bstate.below&&(t.outp.below=e.outp.below,t.bstate.below=0,null!==t.prev&&2===t.prev.bstate.below&&(t.bstate.below=1))}else e.xt=e.top.y===n?e.top.x:e.bot.x+e.dx*(n-e.bot.y);if(N>=b.sbtEntries)continue;const p=new W;p.buildIntersectionTable(g,o);for(let n=p.top;null!==n;n=n.next){if([l,s]=n.ie,!(0===l.bundle.above[c]&&0===l.bundle.above[d]||0===s.bundle.above[c]&&0===s.bundle.above[d])){const o=l.outp.above,r=s.outp.above,i=n.point.x,u=n.point.y+t,b=0!==l.bundle.above[c]&&0===l.bside.clip||0!==s.bundle.above[c]&&0!==s.bside.clip||0===l.bundle.above[c]&&0===s.bundle.above[c]&&1==(l.bside.clip&s.bside.clip)?1:0,a=0!==l.bundle.above[d]&&0===l.bside.subj||0!==s.bundle.above[d]&&0!==s.bside.subj||0===l.bundle.above[d]&&0===s.bundle.above[d]&&1==(l.bside.subj&s.bside.subj)?1:0;let p=0,h=0,x=0,f=0;switch(0===e||1===e?(p=b&a,h=(b^s.bundle.above[c])&(a^s.bundle.above[d]),x=(b^l.bundle.above[c])&(a^l.bundle.above[d]),f=(b^s.bundle.above[c]^l.bundle.above[c])&(a^s.bundle.above[d]^l.bundle.above[d])):2===e?(p=b^a,h=b^s.bundle.above[c]^a^s.bundle.above[d],x=b^l.bundle.above[c]^a^l.bundle.above[d],f=b^s.bundle.above[c]^l.bundle.above[c]^a^s.bundle.above[d]^l.bundle.above[d]):3===e&&(p=b|a,h=b^s.bundle.above[c]|a^s.bundle.above[d],x=b^l.bundle.above[c]|a^l.bundle.above[d],f=b^s.bundle.above[c]^l.bundle.above[c]|a^s.bundle.above[d]^l.bundle.above[d]),E(p,h,x,f)){case 8:case 7:l.outp.above=v.addLocalMin(i,u),s.outp.above=l.outp.above;break;case 4:null!==o&&(o.addRight(i,u),s.outp.above=o,l.outp.above=null);break;case 2:null!==r&&(r.addLeft(i,u),l.outp.above=r,s.outp.above=null);break;case 1:null!==o&&null!==r&&(o.addLeft(i,u),v.mergeRight(o,r),l.outp.above=null,s.outp.above=null);break;case 11:null!==o&&(o.addLeft(i,u),s.outp.above=o,l.outp.above=null);break;case 13:null!==r&&(r.addRight(i,u),l.outp.above=r,s.outp.above=null);break;case 14:null!==o&&null!==r&&(o.addRight(i,u),v.mergeLeft(o,r),l.outp.above=null,s.outp.above=null);break;case 6:null!==o&&null!==r&&(o.addRight(i,u),v.mergeLeft(o,r),l.outp.above=v.addLocalMin(i,u),s.outp.above=l.outp.above);break;case 9:null!==o&&null!==r&&(o.addLeft(i,u),v.mergeRight(o,r),l.outp.above=v.addLocalMin(i,u),s.outp.above=l.outp.above)}}0!==l.bundle.above[c]&&(s.bside.clip=1-s.bside.clip),0!==s.bundle.above[c]&&(l.bside.clip=1-l.bside.clip),0!==l.bundle.above[d]&&(s.bside.subj=1-s.bside.subj),0!==s.bundle.above[d]&&(l.bside.subj=1-l.bside.subj);let{prev:o}=l;const{next:r}=s;if(null!==r&&(r.prev=l),1===l.bstate.above)for(;null!==o&&2===o.bstate.above;)o=o.prev;if(null===g.top)throw new Error("Encountered Unexpected Null Edge");if(null===o)g.top.prev=s,s.next=g.top,g.top=l.next;else{if(null===o.next)throw new Error("Encountered Unexpected Null Edge");o.next.prev=s,s.next=o.next,o.next=l.next}if(null===l.next)throw new Error("Encountered Unexpected Null Edge");l.next.prev=o,s.next.prev=s,l.next=r}for(let e=g.top;null!==e;e=e.next){const{next:t,succ:o}=e;if(e.top.y===n&&null!==o){o.outp.below=e.outp.above,o.bstate.below=e.bstate.above,o.bundle.below[c]=e.bundle.above[c],o.bundle.below[d]=e.bundle.above[d];const{prev:n}=e;null!==n?n.next=o:g.top=o,null!==t&&(t.prev=o),o.prev=n,o.next=t}else e.outp.below=e.outp.above,e.bstate.below=e.bstate.above,e.bundle.below[c]=e.bundle.above[c],e.bundle.below[d]=e.bundle.above[d],e.xb=e.xt;e.outp.above=null}}return v.getResult()}function z(e,t,n){const o=(t.x-e.x)*(n.y-e.y)-(n.x-e.x)*(t.y-e.y);return Math.abs(o)<b?0:Math.sign(o)}var K=(e=>(e[e.INSIDE=1]="INSIDE",e[e.OUTSIDE=-1]="OUTSIDE",e[e.BOUNDARY=0]="BOUNDARY",e))(K||{});function Z(e,t){let n=0;const o=t.length-1;for(let l=0;l<o;l++)if(t[l].y<=e.y){if(t[l+1].y>e.y){const o=z(t[l],t[l+1],e);if(0===o)return 0;o>0&&++n}}else if(t[l+1].y<=e.y){const o=z(t[l],t[l+1],e);if(0===o)return 0;o<0&&--n}return 0===n?-1:1}function $(e,t,n){return(t.y-e.y)*(n.x-e.x)-(t.x-e.x)*(n.y-e.y)}function ee(e){const t=e.length,n=e[0];let o=1;for(let n=2;n<t;n++)for(e[++o]=e[n];o>=2&&$(e[o-2],e[o-1],e[o])>=0;)e[o-1]=e[o],o--;for(;$(e[o-1],e[o],n)>=0;)o--;return e.length=o+1,e}function te(e){const t=e[0];return e.sort(((e,n)=>$(t,e,n)||e.x-n.x)),ee(e)}var ne,oe=class{toJSON(){return this.toVertices()}static n_ary(e,...t){return t.reduce(((t,n)=>Q(e,t,n,le,se)))}static intersection(...e){return oe.n_ary(1,...e)}intersection(...e){return oe.intersection(this,...e)}static union(...e){return oe.n_ary(3,...e)}union(...e){return oe.union(this,...e)}static xor(...e){return oe.n_ary(2,...e)}xor(...e){return oe.xor(this,...e)}static difference(e,...t){switch(t.length){case 0:return e;case 1:return Q(0,e,t[0],le,se);default:{const n=t.reduce(((e,t)=>Q(3,e,t,le,se)));return Q(0,e,n,le,se)}}}difference(...e){return oe.difference(this,...e)}static fromPoints(e){const t=R(1,e=D(e=e.map((e=>Array.isArray(e)?{x:e[0]||0,y:e[1]||0}:e)))),n=new le(e,!1);return n.area=t,n}static holeFromPoints(e){const t=R(-1,e=D(e=e.map((e=>Array.isArray(e)?{x:e[0]||0,y:e[1]||0}:e)))),n=new le(e,!0);return n.area=t,n}static fromVertices({bounds:e,holes:t}){return oe.n_ary(3,...e.map(oe.fromPoints),...t.map(oe.holeFromPoints))}},le=class extends oe{constructor(e,t){super(),this.pointList=e,this.isHole=t,this.hull=null,this.area=NaN,this.json=null,this.contributes=!0,this._bounds=null}equals(e){if(e===this)return!0;if(!(e instanceof le)||this.isHole!==e.isHole)return!1;const{pointList:t}=this,{pointList:n}=e;return t.length===n.length&&t.every((({x:e,y:t},o)=>{const{x:l,y:s}=n[o];return Math.abs(e-l)<b&&Math.abs(t-s)<b}))}get isEmpty(){return 0===this.pointList.length}get bounds(){if(null===this._bounds){let e=Number.MAX_VALUE,t=Number.MAX_VALUE,n=-Number.MAX_VALUE,o=-Number.MAX_VALUE;for(const{x:l,y:s}of this.pointList)l<e&&(e=l),l>n&&(n=l),s<t&&(t=s),s>o&&(o=s);this._bounds=new m(e,t,n,o)}return this._bounds}getInnerPolies(){return[this]}getNumPoints(){return this.pointList.length}get(e){return this.pointList[e]}iterVertices(){return this.pointList[Symbol.iterator]()}getArea(){return isNaN(this.area)&&(this.area=j(this.pointList)),this.area}contains(e){if(e instanceof oe){let t=0,n=0;for(const o of e.iterVertices()){const e=Z(o,this.pointList);1===e?t++:-1===e&&n++}return t>0&&0===n?this.isHole?-1:1:n>0&&0===t?this.isHole?1:-1:0}return e instanceof Array&&(e={x:e[0],y:e[1]}),Z(e,this.pointList)}explode(){return[this]}[h](e){if(0!==e)throw new Error("SimplePolygon only has one poly");return this.contributes}[x](e,t){if(0!==e)throw new Error("SimplePolygon only has one poly");this.contributes=t}toVertices(){return this.json||(this.json=this.isHole?{bounds:[],holes:[this.pointList]}:{bounds:[this.pointList],holes:[]}),this.json}getHull(){return this.hull||(this.hull=V(this.pointList)?this:new le(ee([...this.iterVertices()]),!1)),this.hull}},se=class extends oe{constructor(e){super(),this.polyList=e,this.hull=null,this.area=NaN,this.explosion=null,this.json=null,this._bounds=null,this.polyList.sort(((e,t)=>{const n=e.get(0),o=t.get(0),l=n.y-o.y;return 0===l?n.x-o.x:l})),this.numPoints=e.reduce(((e,t)=>e+t.getNumPoints()),0)}equals(e){return e===this||e instanceof se&&e.polyList.length===this.polyList.length&&this.polyList.every(((t,n)=>t.equals(e.polyList[n])))}get isHole(){return!1}get isEmpty(){return 0===this.polyList.length}get bounds(){if(null===this._bounds){const{polyList:e}=this;if(0===e.length)this._bounds=new m(NaN,NaN,NaN,NaN);else if(1===e.length)this._bounds=this.polyList[0].bounds;else{let e=Number.MAX_VALUE,t=Number.MAX_VALUE,n=-Number.MAX_VALUE,o=-Number.MAX_VALUE;for(const l of this.polyList){const{maxx:s,maxy:r,minx:i,miny:u}=l.bounds;i<e&&(e=i),s>n&&(n=s),u<t&&(t=u),r>o&&(o=r)}this._bounds=new m(e,t,n,o)}}return this._bounds}getInnerPolies(){return this.polyList}getNumPoints(){return this.numPoints}get(e){for(const t of this.polyList){const n=t.getNumPoints();if(e<n)return t.get(e);e-=n}throw new Error("Index out of bounds")}*iterVertices(){for(const e of this.polyList)yield*e.pointList}getArea(){return isNaN(this.area)&&(this.area=this.polyList.reduce(((e,t)=>e+t.getArea()),0)),this.area}contains(e){if(e instanceof oe){let t=0,n=0;for(const o of e.iterVertices()){this.polyList.some((e=>-1!==e.contains(o)))?t++:n++}return t>0&&0===n?1:n>0&&0===t?-1:0}e instanceof Array&&(e={x:e[0],y:e[1]});let t=0,n=0;for(const o of this.polyList){const l=o.contains(e);1===l?t++:0===l&&n++}return t>0?1:n>0?0:-1}explode(){if(this.explosion)return this.explosion;const e=[],t=new Set;for(const n of this.polyList)n.isHole?t.add(n):e.push(n);if(1===e.length)this.explosion=[this];else{const n=[];for(const o of e){const e=[o];for(const n of t)1===Z(n.get(0),o.pointList)&&(e.push(n),t.delete(n));1===e.length?n.push(o):n.push(new se(e))}this.explosion=n}return this.explosion}[h](e){return this.polyList[e][h](0)}[x](e,t){this.polyList[e][x](0,t)}toVertices(){if(!this.json){const e=[],t=[];for(const n of this.polyList){const{bounds:o,holes:l}=n.toVertices();e.push(...o),t.push(...l)}this.json={bounds:e,holes:t}}return this.json}getHull(){if(this.hull)return this.hull;if(this.explode()[0]===this)this.hull=this.polyList[0].getHull();else{const e=[];for(const t of this.polyList)if(!t.isHole)for(const n of t.getHull().iterVertices())e.push(n);this.hull=new le(te(e),!1)}return this.hull}};return ne=l,((l,s,r,i)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let u of n(s))o.call(l,u)||u===r||e(l,u,{get:()=>s[u],enumerable:!(i=t(s,u))||i.enumerable});return l})(e({},"__esModule",{value:!0}),ne)})();
